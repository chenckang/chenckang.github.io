---
layout: post
title: "函数式编程"
date: 2016-07-11 12:20:04
image: '/assets/img/'
description: 这是一种古老的编程思想，在历史的进程中一度被忽视，但是今年来发现其思想拥有无与伦比的价值，甚至出现了诸如Erlang这种函数是语言。这个问题从λ演算开始，事实证明λ演算和图灵机等价……
main-class: 'css'
tags:
- theory
categories:
---

# 函数式编程

<p class="cite"><a href="http://www.defmacro.org/ramblings/fp.html">原文地址：Functional Programming For The Rest of Us</a></p>

## 介绍

程序员都是拖延症患者，进来了，喝点咖啡，检查下邮箱，读读RSS推送文章，看下新闻，在技术类网站上看下最近的文章，浏览下特定编程论坛上的讨论。反复刷新确保没遗漏什么东西。去吃午饭后回来，盯着编辑器几分钟，检查邮件，喝点咖啡。不知不觉中一天就这样过去了。

只有一件事，每当一个充满挑战的文章冒出来了。如果你所浏览网站是正确的，你会每隔几天发现一篇这样的文章。这些文章很难阅读并且会花点时间，所以它们也就堆积起来了。在你察觉之前，已经有一个收藏列表以及一个满是PDF文件的文件夹，然后你就希望能够有一年时间在森林中央的一个小屋内去追赶上这些东西并且没有人打扰到你。如果每天早上当你沿着河畔散步时，有人能够给你带来点食物顺便带走你的垃圾就更好了。

我并不是特别清楚你的列表内容，但是我的列表中有一大部分是关于函数式编程。这些通常是最难看懂的。使用枯燥的学院派语言，甚至工作十年的华尔街老前辈都不懂函数式编程（也称作FP）是什么。如果你问一个花旗集团的项目经理或者德意志银行的，为什么他们使用JMS而不是Erlang，他们会说他们不能使用学院派语言用于企业级的应用。问题在于，一些要求最严并且最复杂的系统是使用函数式编程元素来实现的。事情听起来似乎不太对劲。

FP的文档和论文确实难以被人们理解，但是他们不是一定要这样。知识的鸿沟完全是历史的原因。FP并没有本质上难以理解的概念。你可以将这篇文章看做FP的入门指南，一个从我们指令语言思想连接到FP世界的桥梁。拿一杯咖啡过来继续阅读吧。或许你的同事会立即开始取笑你的FP注释。

那么是FP呢？它都是关于什么的？能吃吗？如果能够像提倡他们的人所说的那样有用，为什么他们在企业级的应用中不怎么被使用呢？为什么仅仅是有PhD学位的人倾向于使用它？最重要的，为什么它那么难以被理解？闭包、连续、柯里化、延迟执行以及无副作用业务是什么？在非大学里的项目中如何使用它？它为什么和看上去好的东西差距那么大以及我们所喜爱的指令语言？我们很快会解释这些问题。让我们开始解释真实世界和学院派文章之间的巨大差异的原因。答案和去公园散步一样简单。

## 去公园散步

启动时光机器。我们这次在公园里的散步发生在2000年之前，在公元前380年的一个被遗忘很久的春季，在一个美丽的晴天下。雅典城之外，在令人愉悦的橄榄树的阴影下，柏拉图在一个漂亮的奴隶小男孩的陪同下朝着学院走去。天气很宜人，晚餐也吃得很饱，谈话变得有点哲学了。

“看那两个学生”，柏拉图小心的说话让这个问题更加有教育性。“你认为那个更高？”奴隶小男孩看向这两个人所站的水池，说：”他们一样高“。柏拉图问：”你说的一样是什么意思“。”好吧，他们从这看上去是一样的，但是如果靠近过他们的话，就能看出一些不同。“

柏拉图笑了。他将这个小男孩引导到了正确的方向。”所以你会说，世界上没有什么是绝对相等的。”小男孩思考了一下回答：“是的，每个东西都有一点不同，即使我们看不到。“这个观点切中要害！”那么，如果没有东西是绝对相等的，你这么看待自己理解绝对相等这个概念呢？“小男孩看上去很困惑。“我不知道”，他回复到。

所以第一次去尝试理解数学的本质尝试也就诞生了。柏拉图认为我们世界的每个东西只是近似于完美。他也意识到我们理解完美的含义即使我们从来没有见过完美的事物。他得出结论：几乎完美的数学形式一定存在于另一个世界中，并且我们通过和那个世界的某种联络所以理解了它们。显然就我们所观察到的事物中不存在完美的圆形。但是，我们也理解完美的圆是何物，也能通过方程来描述它。那么数学是什么呢？为什么这个世界可以使用数据的法则来描述？我们的宇宙的所有现象都可以用数据来描述吗？

数学的哲学是非常复杂的话题。就像大多数哲学规则一样，它更多的是抛出问题而不是解决问题。很多公式围绕在数学非常令人困惑的事实之上：我们设定了一系列基本的无冲突法则以及一些定义如何操作这些法则的定律。于是我们将这些定律聚在一起而得出一个更复杂的定律。数学家称这种方式为形式系统或者演算。如果我们愿意我们可以为俄罗斯方块写一个形式系统。事实上，俄罗斯方块的实现就是一个形式系统，仅仅使用一种不同寻常的表现来阐述。

在阿尔法半人马座上的有毛生物的文明可能无法理解我们的俄罗斯方块的系统以及圆形，因为他们感觉器官或许只是嗅觉。他们可能永远不会发现俄罗斯方块的系统，但是他们的系统可能会对圆形系统有所感知。而我们很可能不能感知的到，因为我们的嗅觉器官并没有那么高级，但是一旦你理解了系统的表现形式（通过各种各样的感觉器官以及标准解码技术来理解这个语言），埋藏在其背后的概念是可以被任何智慧文明所接纳理解的。

有趣的是，如果宇宙中没有智慧的文明的存在，俄罗斯方块及圆形系统仍然存在，只是没有人能够去发现他们。如果一个智慧文明出现了，它就有可能发现一些系统来帮助他们描述和记录他们所在宇宙的法则。他们当然不太可能发现俄罗斯方块，因为在那个世界没有东西和俄罗斯方块相似。俄罗斯方块是无数形式系统的一个案例，一个在现实世界不存在的问题。我们甚至无法确定自然数和现实世界是否完全相似，毕竟人们可以很容易想到一个足够大的数字，而这个数字并不能描述我们宇宙的任何事物，即使这个数字实际上是有限大的。

## 一点历史

让我们的时光机转起来。这一次我们去一个稍微近一点的年代，1930年左右。经济大萧条破坏了了新老世界。几乎社会上的每个角落的所有家庭都受此大规模的经济奔溃的影响。只有少数几个圣殿免于灾难，人们在那里免于贫困的威胁。只有少数人足够幸运的处于这样的圣殿之上，但是他们确实存在。现在将我们的关注点集中在普林斯顿大学。

哥特式的新办公建筑给了普林斯顿大学一个安全天堂的光环。世界各地的逻辑学者被邀请至普林斯顿大学去建立一个新的学院。当大多数的美国人无法为晚餐找到一片面包时，高高的屋顶，用精心雕琢的木质墙，喝一杯茶进行日常讨论，漫步走向森林是当时普林斯顿的基本状态。

其中有一个数学家生活在这样的奢侈的环境中，一个叫做Alonzo Church的年轻人。Alonzo从普林斯顿获取了理学学士的学位，并且被说服留在了研究所内。Alonzo感觉到普林斯顿的这种状态更多的是空想主义而不是实际和必要的。他很少出面去边喝茶边讨论数学并且并不喜欢在森林里面散步。Alonzo是一个不合群的人：当他独自一人工作的时候效率是最高的。然而Alonzo也和其他的普林斯顿的居住者们有联系。他们中有Alan Turing，John Von Neumann, 以及Kuit Godel。

这四个人对形式系统感兴趣。他们并不在意现实世界，取而代之的是他们对解决抽象的数据问题感兴趣。这些问题有些共同点：他们在尝试解答关于计算的问题。如果我们有机器具备无限计算的能力，那么什么问题能够被解决？我们能通过自动的手段解决他们吗？一些问题会无法解决吗？以及为什么无法解决？为了不同的目的所设计的机器在能力上是相等的吗？

在和其他人合作的中，Alonzo Church发现了一种新式系统称作lambda演算。这个系统本质上是针对这些想象中的机器的一个编程语言。这基于将函数作为参数传入并且返回函数作为结果。函数名称用希腊字母lambda表示，因此也是这个系统的名字。使用这个系统，Alonzo能够推导出很多上面列出的问题，并且提供结论性的答案。

独立于Alonzo Church，Turing也在从事相似的工作。他发明了一个不同的系统（现在称为图灵机），并且使用它独立的得出了和Alonzo相似的结论。后来，图灵机以及lambda演算被证明是能力相等的。

如果不是二战，故事到此为止，我完成了文章，你去看其他的东西了。当时整个世界都陷入了战争的泥淖中。美国军队以及海军比以前任何时候更频繁的使用大炮。在尝试提高精度时，军队雇佣了大量的数学家来不断的计算炮弹的轨迹。很明显任务很难用人工来一一计算，很多设备被发明出来解决这个问题。第一个用来解决这个问题的机器是IBM的Mark I, 它重达五吨，有750000个零件，可以每秒计算三次。

故事还没结束。1949年，EDVAC(电子数据计算机)问世并且获得了极大的成功。这是冯诺依曼机器的一个原型，是图灵机的一个现实的高效率的实现。但这时Alonzo Church却并没有这个运气受到大家的关注。

1950年代后期，MIT教授John McCarthy(也是普灵斯顿的毕业生）对Alonzo Church的工作产生了兴趣。1958年，他揭开了List Processing Language(LISP)的神秘面纱。Lisp是Alonzo的lambda演算的一个实现，并且工作在冯诺依曼机器上。很多计算机科学家认识到了Lisp语言的强大的表达能力。1973年，MIT的人工智能中心的一群科学家们，发明了一种硬件叫做：Lisp机器，是Alonzo的lambda演算的一个硬件实现。

## 函数式编程

函数式编程是Alonzo Church的想法的一个实际的实现。并不是所有的lambda演算的想法都被实现了，因为它并不是为具有物理限制的机器而设计的。因此，就像面向对象编程一样，函数式编程是一系列的思想，而不是一些严格法则。有很多函数式编程的语言，他们中的大多数在做非常不同的事。在这篇文章中，我会使用Java语言介绍函数式编程中的大多数被广泛使用的思想。在接下来的几张中，我们会引入Java，并且会稍作转化使得它成为一个可用的函数式语言。现在开始我们的探索。

Lamdba演算被设计用于解决和计算相关的问题。因此函数式编程则主要用于计算，令人惊讶的是它是用函数来完成的。在函数式编程中函数是基本的单元。函数可用于几乎所有事情中，甚至最简单的运算。甚至连变量都由函数来替代。在函数式编程中，变量仅仅是表达式的别名（所以我们不用在一行中输入所有的内容）。他们是不能被更改的。所有的变量只能赋值一次。用Java的话语体系来描述也就是每个单独的变量都被声明为final(相当于c++中的const)。在FP中没有非final的变量。

{% highlight java %}
final int i = 5;
final int j = i + 3;
{% endhighlight %}

既然FP中的变量都是final的，那么可以得出两个有趣的结论。针对变量使用关键字final是没有意义的，以及称它们为变量也是无意义的，好吧……变量。我们现在针对Java做两个改动：在我们的Java函数中声明的每个变量都是默认为final，以及我们用符号指向变量。

现在，你或许会怀疑如何使用我们新创建的语言写一个复杂度合理的东西。如果所有的符号都是不可变的，我们就不能改变任何东西的状态！这个观点不是绝对正确的。当Alonzo在研究lambda演算时，他对为了之后改变事物的状态而事先维护一个状态并不感兴趣。他对数据上的操作更感兴趣（也被公认为“计算实体”）。然而，事实证明lambda演算等同于图灵机。它可以做任何编程语言能做的事情。那么如何才能得到同样的结果呢？

事实是函数式编程可以保持状态，只是它们不通过变量来实现。它们使用的是函数。状态保留在函数的参数中，在栈中。如果你想保留状态一段时间，并且随后去修改它们，你可以写一个递归函数。作为一个例子，我们来写一个反转字符串的Java函数。记住，每个变量默认都是final的。
{% highlight java %}
String reverse(String arg) {
  if (arg.length == 0) {
    return arg;
  }
  else {
    return reverse(arg.subtring(1, arg.length)) + arg.subtring(0, 1);
  }
}
{% endhighlight %}
这个方法很慢，因为他不断的调用自己。并且也会很耗内存，因为它不断的分配对象。但是这就是函数式的风格。你或许会感兴趣谁会以这种方式来编程。好的，我正要告诉你。

## FP的优点

你或许在想绝不可能将上面这个怪物般的函数变得合理。当我在学习函数式编程，我也在思考同样的问题。但是我错了。有很好的理由来使用这种方式。有些理由是主观的。例如，有人声称函数式风格的程序很易读。下面我将忽略这些主观观点，因为每个人都知道理解的难易度取决于旁观者的视角。很幸运，对我而言，针对这个问题有很多客观的理由。

### 单元测试

因为FP中的每个符号都是final的，函数不会有副作用。你不能就地改变一些东西，函数也不能改变其外部作用域中被其他函数所使用的变量（例如类的成员或者全局变量）。那也就意味着执行函数的唯一效果就是函数返回的值，以及唯一影响函数的返回值的就是函数的参数。

这是单元测试者的愿望。你可以测试程序中的每一个函数而仅仅需要关心参数。你不用担心是否按照正确的顺序调用了函数，或者设置了符合要求的外部状态。你所需要做的就是传递边界条件的参数。如果每个函数都通过了单元测试，你就可以对自己的软件质量更加有信心。在Java或者C++中，检查函数的返回值并不足够 —— 它可能会更改外部的状态，而这个也是需要验证的。而在函数式编程中却不是这样。

### 调试

如果函数式程序并不像你期望的那样执行，调试变得轻而易举。你总可以重现你的问题，因为函数式的程序中bug并不依赖于在它之前的不相关的代码。在一个指令式程序中一个bug仅仅在一些时间才会重新出现。因为函数依赖于外部的状态，改变了外部状态的那些函数所带来的副作用也是你要考察的点，而这个函数并不和这个bug直接关联。在函数式的程序中，这就不是问题了——如果函数返回值是错的，那他就一直是错的，不论在这函数之前执行了什么。

一旦复现了问题，追踪到问题的根源是很简单的。这总是让人愉快。你给程序打断点并且检查栈。每个在栈中的函数调用的参数都可以被检查到。就像命令式的程序一样。除了指令式程序的函数还依赖于外部的成员变量、全局变量、以及其他类的状态（这些类也同样依赖于相同的东西）。在函数式的程序中，函数仅仅依赖于参数，信息就在你的眼前。更进一步的，命令式的程序检查函数的返回值并不会让你清楚的知道函数是否正常工作。你需要追踪作用域之外的一系列对象，去检查他们是否正确的执行了。在函数式的程序中，你只需要检查返回值。

在栈中查找，你只需要查看传递给函数的参数以及返回值。一旦返回值无效，你就可以进入异常的函数中，并且检查是其是否正常。你不断的重复这个过程直到找到bug的源头。

### 并发

函数式程序可以直接用于并发而不用任何进一步的修改。你从不用担心死锁或者竞争条件，因为根本不需要锁。函数式的程序中不会有数据会被一个进程改变两次，更不用说两个进程。这也就意味着，可以很容易的不假思索的增加进程而不用担心引入瘫痪并发应用的常见问题。

如果事实如此，为什么大家不使用函数式编程用于并发应用呢？好吧，事实上他们确实做了这事。Ericsson设计了一个函数式语言Erlang，这个语言有着很高的容错性并且可以进行可扩展的远程通信切换。很多人开始意识到Erlang语言所带来的便利而使用它。我们在讨论远程通信以及交通控制系统，这些系统要比华尔街的那些系统要求具备更高的可扩展性以及可靠性。实际上，Erlang系统并不是可扩展以及可靠的，Java系统才是。Erlang系统只不过是如磐石般坚固而已。

我们接着来看下其他关于并发的内容。如果你的程序本质上是一个单进程的，编译器仍然可以优化函数式程序使得他们可以在大多数CPU上运行。看下下面的代码片段：
{% highlight java%}
String s1 = somewhatLongOperation1();
String s2 = somwwhatLongOperation2();
String s3 = concatenate(s1, s2);
{% endhighlight %}
在函数式的语言中，编译器可以分析代码，将生成s1及s2的代码归类为耗时的操作，然后并发的执行他们。这在一般的指令式语言中是无法做到的，因为每个函数可能改变作用域外的状态，而后面的函数可能会依赖于外部状态。在函数式的语言中，自动分析函数以及寻找好的并发执行的方式就如同自动内联一样平常。从这个意义上来说，函数式风格的编程是“未来的编程风格”（尽管我讨厌浮夸的词汇，但是这次我沉浸于此）。硬件厂商无法再制造更快的CPU了。取而代之是他们开始增加内核的数量使用并发来实现成倍的速度提升。当然他们却绝口不提这让我们将更多的成本投入到了开发能够并行处理问题的软件上。并发问题是指令式程序的一小部分却是函数式程序的全部，因为函数式程序都天然的处理了并行问题。

### 热部署

在以前的windows上，为了安装更新，需要重启电脑。很多时候是在安装了一个新版的媒体播放器时。在Windows XP上问题得到了很大的改善，但是也不够理想（我在工作日安装了一个更新，一个恼人的托盘图标会一直存在，直到我重启电脑）。Unix系统一直有一个更好的模式。想要安装更新，只要关闭相关的模块就好，而不是整个系统。尽管这已经很好了，但是针对大型的服务端软件仍然是不可接手的。远程通信系统需要一直开启，因为如果医疗急救电话在系统升级的时候打不通，那么就会出人命。华尔街的人也没有理由在周末为了安装软件升级而关闭系统。

一个理想的情况就是不用停止整个系统而仅仅是更新相关部分的代码。在命令是语言的世界这是不可能的。想象下在运行时卸载掉一个Java类并且重新加载一个新的类定义。如果我们能够这样做，这个类的每一个实例都没用了，因为它的状态将会丢失。我们可以通过编写巧妙的版本控制代码来实现热部署。将所有的运行中的实例给序列化，销毁他们，创建新类的实例，试着去将序列化的数据加载到它们中，期待着加载的数据恰当的被迁移到新的实例上。那么这样每次我们改变一点东西，我们要编写迁移代码。迁移代码也要很小心的维护以防止破坏了对象间的关联。在理论上可行，但是实际中却难以很好的执行。

在函数式程序中，所有的状态都被存在栈中，作为参数传递给函数。这使得热部署变得异常简单。实际上，我们只需要diff下产品中的代码和新版代码，然后将新代码部署好即可。剩下的可以通过语言工具自动完成。如果你认为这是科幻小说，再想一下。Erlang的工程师已经可以在长达几年的时间内升级运行中的程序而不用关闭他们。

### 机器辅助证明及优化

函数式语言的一个有意思的特性是他们可以通过数学来推理。既然函数式语言只是一个形式系统的实现，所有能够在纸上进行的数学操作也适用于有函数式语言编写的程序。例如，编译器可以将代码片段编译为更加高效的对等体，在数学理论上可以得出两个部分又是对等的。关系数据库已经针对此优化了数年。针对普通的软件同样的技术也没有理由不成立。

另外，你可以使用一些方法证明你的程序的一部分是正确的。甚至可以创建工具来分析代码，生成边界条件来进行自动的单元测试。这个能力对一个健壮系统的价值是无法估量的。如果你在设计起搏器或者航空系统这些工具都总是必须的一个要求。如果你设计的不是这种功能敏感的应用，这些工具也能帮助你相对于竞争对手取得很大的优势。

## 高阶函数

我记得上面提到了不少有点并且也说了”这些优点都挺不错的，但是如果我不得不用一个所有变量都是final的蹩脚语言来编写代码，这就彻底抵消了这些优点“。这其实是一个误解。在指令式语言中，让所有变量都是final是非常难以处理的，但是在函数式语言中就不是这么回事了。函数式语言提供了非常抽象的机制，让你忘记你需要修改变量。其中一个机制就是高阶函数。

这种语言中的函数和Java以及C中的函数不是一个概念。它是一个超集——可以做任何Java函数可以做的事，甚至更多。创建函数的方式和在C中的创建的方式类似：
{% highlight java%}
int add(int i, int j) {
  return i + j;
}
{% endhighlight %}
相比于C中同样的代码，这里会有所不同。让我们拓展下我们的Java编译器来支持这种写法。当我们敲入诸如这段代码，我们的编译器将它编译成下面的Java代码（别忘了，所有东西都是final的）：
{% highlight java%}
class add_function_t {
  int add(int i, int j) {
    return i + j;
  }
}

add_function_t add = new add_function_t();
{% endhighlight %}
`add`符号并不是真的函数。这是一个只有一个成员函数的简单的类。现在我们能够将`add`作为参数传递给其他函数。我们可以将它赋给另一个符号。我们可以在运行时创建`add_function_t`的实例，并且当我们不再需要他们的时候会被垃圾回收掉。这让函数成为一等对象，和整数及字符串一个级别。那些操作其他函数的函数（接受其他函数作为参数的函数）被称为高阶函数。不要被概念唬住了，这和相互之间操作对方的Java类没有什么不同（我们可以将类的实例传递给其他的类）。我们可以称他们为”高阶类“，但是没人关心这个问题，因为在Java背后并没有强大的学院派社区。

如何，以及何时，使用高阶函数？好吧，我很高兴你问这个问题了。你写了一大段代码而不用关心代码层级问题。当你看到一个特殊的代码片段不断的重复，你将它抽离出一个函数（辛运的是，在学校里面教过这些东西）。如果你所写的函数中的一个代码片段在不同的情况下执行不同的逻辑，你就可以将它抽离出一个高阶函数。还没懂？这里有个我遇到的真实案例。

假设，我们有一段代码接受消息，用不同的方法转换它们，并把它们传递给不同的服务器。
{% highlight java%}
class MessageHandler {
  void handleMessage(Message msg) {
    msg.setClientCode("ABCD_123");
    sendMessage(msg);
  }
}
{% endhighlight %}
现在假设我们的系统升级了，现在需要将路由信息发送给两台机器。
除了相关的终端选择那部分代码，其他的东西都不用动 —— 第二台机器希望使用不同的格式。我们如何处理这个情况？我们可以检查消息要发送到哪里然后将消息格式化为不同的格式，就像这样：
{% highlight java%}
abstract class MessageHandler {
  void handleMessage(Message msg) {
    // ...
    if (msg.getDestination().equals("server1") {
      msg.setClientCode("ABCD_123");
    }
    else {
      msg.setClientCode("123_ABC");
    }

    // ...
    sendMessage(msg);
  }

  // ...
}
{% endhighlight %}
然而这个方法并没有拓展性。如果有更多的服务器要被添加进来，我们的函数就会线性增长，这样跟新这个函数就会成为噩梦。用面向对象的方式来构造就是让`MessageHandler`成为一个基类，然后在具体的子类中实现不同的终端选择逻辑。
{% highlight java%}
abstract class MessageHandler {
  void handleMessage(Message msg) {
    // ...
    msg.setClientCode(getClientCode());
    // ...

    sendMessage(msg);
  }

  abstract String getClientCode();

  // ...
}

class MessageHandlerOne extends MessageHandler {
  String getClientCode() {
    return "ABCD_123";
  }
}

class MessageHandlerTwo extends MessageHandler {
  String getClientCode() {
    return "123_ABCD";
  }
}
{% endhighlight %}
现在我们可以针对不同的服务器实例化不同的类。增加服务器变得更加易于维护。然而这对这么简单的改动还是要写不少代码的。我们不得不再创建两个类来支持不同的终端。现在我们在支持高阶函数的语言中实现相同的事情：
{% highlight java%}
class MessageHandler {
  void handleMessage(Message, Function getClientCode) {
    // ...
    Message msg1 = msg.setClientCode(getClientCode());
    // ...
    sendMessage(msg1);
  }
}

String getClientCodeOne() {
  return "ABCD_123";
}

String getClientCodeTwo() {
  return "123_ABCD";
}

MessageHandler handler = new MessageHandler();
handler.handleMessage(someMsg, getClientCodeOne());
{% endhighlight %}
我们没有创建任何新的类型以及类。我们只是简单的将不同的函数作为参数传递进去而已。我们做到了面向对象中同样的事情，但是实现起来却简单的多了。我们不用将我们自己限定在类的层级中：我们可以将函数在运行时传入，并且使用更少的代码在任何时候以更加细粒度的方式来做出调整。编译器帮我们处理了面向对象底层实现。而我们获得了所有FP的好处。当然，函数式语言所提供的抽象并不就此为止。高阶函数才刚刚开始。

## 函数柯里化

我认识的大多数人都读过由四人帮写（the Gang of Four）的《设计模式》。任何合格的程序员会告诉你这本书是语言无关的，这些模式适用于一般性的软件工程中无论你有什么语言来实现的。这曾经是金科玉律。不幸的是现在这已经不再是事实了。

函数式编程具备很强的表达能力。在函数式的语言中，人们不需要设计模式，因为语言本身已近足够高级，你最终在无任何设计模式的指导下进行编程。其中一个模式是适配器模式（它和门面模式有什么不同？听起来有人要多看几页书才能符合自己当初的就业合同的要求了）。一旦语言支持了柯里化，这些都不再是问题了。

适配器模式适用于Java里面默认的抽象单元 —— 类。在函数式语言中这个模式将应用于函数中。这个模式针将接口转化为另一个接口来满足其他人的需求。这里有个适配器模式的一个例子：
{% highlight java%}
int pow(int i, int j);
int square(int i) {
  return pow(i, 2);
}
{% endhighlight %}
上面的这个代码适配一个函数的接口，将一个求整数的整数次幂方函数转换为求整数的平方的函数。在学术圈，这个常见技巧叫做柯里化（在一个逻辑学家Haskell Curry用数学的方式将其归纳之后而命名）。因为在FP中，函数被作为参数传递，柯里化将一个函数适配成其他人所期望的形式。因为函数的接口就是其参数，柯里化用于减少参数的个数（就像上面那样）。

函数式编程中自带这种技术。你不需要手动创建一个包裹原函数的函数，函数式语言会为你实现。下面，我们来扩展我们的语言来实现这些：
{% highlight java%}
square = int pow(int i, 2)
{% endhighlight %}
这会为我们自动创建一个只有一个参数的`square`函数。它会调用`pow`函数，并且设置第二个参数为2。其编译成Java代码如下：
{% highlight java%}
class square_function_t {
  int square(int i) {
    return pow(i, 2);
  }
}

square_function_t square = new square_function_t();
{% endhighlight %}
就像你看到的那样，我们自动创建了一个包裹器包裹原始的函数。在FP柯里化中，这作为快速创建一个包裹函数的快捷方式。你关注于自己的开发任务，编译器替你完成适当的代码。你什么时候使用柯里化？这很简单。答案就是任何时候你想使用适配器时候（一个包裹器）。

## 延迟执行

一旦我们采用函数式哲学，我们就可以做到懒执行或者延迟执行。当我们讨论并发的时候，或许已经看过下面的代码片段
{% highlight java%}
String s1 = somewhatLongOperation();
String s2 = somewhatLongOperation();
String s3 = concatenate(s1, s2);
{% endhighlight %}
在指令性语言中，代码的执行顺序很明确。因为每个函数都会影响或者依赖于外部的状态，按顺序执行代码是必须的：首先`somewhatLongOperation1`, 其次就是`somewhatLongOperation2`, 紧接着后面就是`concatenate`操作。函数式语言却有所不同。

就像我们之前所说的`somewhatLongOperation1`和`somewhatLongOperation2`可以并发的执行，原因就是我们保证函数都不影响或者依赖于全局环境。但是，如果我们不想并发的执行这两个操作，我们需要按顺序执行他们吗？答案是否定的。我们仅仅需要在其他的函数依赖于`s1`和`s2`时才去执行这些操作。我们甚至在`concatenate`执行前都不需要运行他们，可以将执行延迟到当`concatenate`中要调用它们的那个地方。如果我们用函数去实现`concatenate`，其中包含一个条件判断并且只使用函数两个参数中的一个，那么我们可能永远不会执行另一个参数。Haskell是一个延迟程序语言执行的一个例子。在Haskell中，不会承诺你所有的东西是按序执行的（或者完全不是按序执行），因为Haskell只在要调用这段代码时才会去执行它。

延迟执行有很多好处，同时也有很多坏处。我们这里先讨论好处，下一部分我们再来讨论坏处。

### 优化

延迟执行为优化提供了巨大的潜力。一个延迟编译器看待函数就如同数学家看待代数表达式一样 - 可以取消执行的结果，并完全的阻止执行，重新安排这些代码片段以获得更好的效率，甚至用一种减少异常的方式来重新组织代码，所有的优化都不会破坏代码的逻辑。这就是使用形式化的基本单元来实现程序的最大的好处——代码遵守数学法则并且可以通过数学的方式来推理。

### 抽象控制结构

延迟执行提供了更高级的抽象级来实现一些原本不可能的事。例如，考虑实现下面的控制结构
{% highlight java%}
unless(stock.isEuropean()) {
  sendToSEC(stock);
}
{% endhighlight %}
仅在stock是European的情况下执行`sendToSEC`。我们如何实现`unless`？如果没有延迟执行，我们就需要一个宏系统，但是在类似于Haskell的语言中就用不着。我们可以用函数的方式实现`unless`。
{% highlight java%}
void unless(boolean condition, List code) {
  if (!condtion) {
    code;
  }
}
{% endhighlight %}
注意，`code`在条件为真时时不会执行的。我们在一个严格的语言中无法做到这样，因为参数会在程序进入`unless`之前就被执行。

### 无限数据结构

延迟执行允许定义无限的数据结构，有时在严格的语言中做到这些就会非常麻烦。例如，考虑一个斐波那契列表。我们很显然无法在有限的时间内计算一个无穷的列表或者将他们存到内存中。在如Java这种严格语言中，我们仅仅简单的定义一个斐波那契函数从一个队列中返回一个特定的数值。在类如Haskell语言中，我们可以进一步将之抽象，就是简单的定义一个无穷的斐波拉切列表。因为语言是延迟执行的，实际上只有列表中需要用到的部分才会被执行。这就可以抽象化很多问题并且从一个更高的视角来看待他们（例如，我们可以针对一个无限的队列使用列表处理函数）。

### 劣势

当然没有免费的午餐。延迟执行也伴随者各种问题。好吧，最主要的问题就是延迟。很多实际的问题需要严格的执行。例如，考虑下面的情况：
{% highlight java%}
System.out.println("Please enter your name");
System.out.readLine();
{% endhighlight %}
在延迟执行语言中，无法保证第一句会在第二句前执行！也就意味着你无法做IO操作，无法使用各种各样的原生方法（因为他们依赖于外部状态，所以必须按序执行），并且它们也无法和外部交互！如果我们引入顺序执行的基本机制也就意味着失去了用数学的方式推导程序的好处（这也就剥夺了函数式编程的所有优点）。幸运的是也不完全如此。数据家们发现了一系列的技巧确保代码在函数层面上按照一个特定的顺序执行。我们在两方面都尽量做的最好。这些技巧包含连续，单体以及唯一类型。这篇文章中，我们仅仅讨论下连续，后续我们会接招讨论单体和唯一类型。有趣的是，连续在很多方面都很有用而不仅仅是按序执行上。我们下面来讨论下连续。

## 连续

连续对于编程就如同达芬奇密码对人类历史一样：对人类未知事物的一个惊人的揭示。好吧，也许不是，但是它们确实是一种欺骗的体现就如同对负数求根号一样。

当我们讨论函数时，我们仅仅是认识到真相的一半，这个真相基于一个错误的假设：函数必须将值返回给他们的原始调用者。从这个意义上俩讲，连续是函数的一个概括。一个函数不是必须返回给它的调用者，也可以返回给程序的任何部分。”连续“是一个传递函数作为参数来指定调用函数应该向哪里返回的方法。这个描述比听起来更加的复杂。看下下面的代码：
{% highlight java%}
int i = add(5, 10);
int j = square(i);
{% endhighlight %}
`add`函数返回15赋值给`i`，这样`add`将值返回给了其原始的调用者。在第一句话之后，`i`被`square`调用。注意，延迟编译器无法重新安排这些代码行，因为第二行依赖于第一行的成功执行。我们可以使用___Continuation Passing Style___或者___CPS___，使`add`函数不向其原始调用者处返回，而是返回给`square`。
{% highlight java%}
int j = add(5, 10, square)
{% endhighlight %}
这样，`add`获得了一个新的参数 —— 当`add`执行完毕时会将执行结果传递给它。这种情况下`square`是`add`的一个连续。在上面这两种情况下，`j`都等于255。

第一个在延迟执行语言中强制顺序执行的技巧就诞生了。考虑下面的（上面有提过）IO代码：
{% highlight java%}
System.out.println("Please enter you name: ");
System.in.readLine();
{% endhighlight %}
这两行相互之间无依赖关系，编译器可以自行重新安排执行顺序。然而，如果我们在CPS中实现这个代码，就会存在依赖，编译器会强制按序执行这两行代码！
{% highlight java%}
System.out.println("Please enter your name:", System.in.readLine);
{% endhighlight %}
在这种情况下，`println`会将调用`readLine`并将自己的执行结果传递给它，最终返回`readLine`的执行结果。这就让我们可以按序执行这两行代码，并`readLine`最终会被执行（因为整个程序等待着最后的执行结果）。在Java中，`println`返回`void`，但是如果可以返回一个抽象的值（传入给`readLine`），问题就解决了。这样的链式调用函数会迅速的让程序变得不易读，但是也可以避免。我们可以增加语法糖来让我们可以简单的顺序编写程序的表达式，编译器会自动将所有的调用都串起来。我们现在以任何顺序执行代码，而无需丢失FP的优势（包括用数学的方式来推导程序）！如果你仍感感到困惑，记住函数只是有一个成员的类的一个实例。将上面的代码用类的实例来重写一下就会豁然开朗。

现在我完成了这一节，除了只是仅仅探索了连续的表面内容及用处。我们可以用CPS来完成整个程序，那样每个函数就多了一个额外的参数并将自己的执行结果传递给它。我们也可以通单的将函数看做是一类特殊的连续，从而将任何程序转换为CPS（函数总是返回给他们的调用者）。这个转换也很容易做到自动化（实际上，很多编译器都做到了）。

一旦我们将程序转换为CPS，很明显每个指令都有某种连续，就是一个函数被当前指令使用其执行结果作为参数来调用，而在一般的程序中是指令返回的地方。我们从上面的代码中选择一个指令，例如`add(5, 10)`。在使用CPS实现的程序中，`add`的连续很显然就是一个其执行完后所要调用的函数。但是non-CPS程序又是什么呢？我们当然可以将程序转化为CPS，但是这是必须的吗？

结论是否定的。仔细看下我们的CPS转换。如果我们试着写一个编译器，仔细的思考它你会意识到CPS版本的程序不需要栈。在一般情况下，没有函数需要”return“，而仅仅是使用其结果去调用另一个函数。我们不需要将函数的参数追加到每个函数调用的栈中，然后再弹出来，我们只需要将他们存在一个特定的内存区域中，在使用一个跳转指令来取代栈。我们不需要原始的参数 —— 因为没有函数会返回所以它们不会被再次使用。

所以，使用CPS风格实现的程序没有栈，但是却有一个额外待执行的函数作为参数。没有使用CPS风格的程序则没有这个参数，但是却有栈。栈中包含什么？仅仅是参数，以及指向到内存中的一个特地区域的指针，在那里函数会返回。你看到了吗？栈中就包含了连续的信息！栈中的返回指令本质上和CPS程序中的函数调用是一样的。如果你想要找到`add(5, 10)`中的连续，你只需要查看下执行到那个函数时栈中的信息。

所以很简单。连续和栈中返回指令中的指针是一个东西，只是连续是被显式传递的，所以它不需要和函数调用处于一个地方。如果你还记得连续是一个函数，而在我们的语言中函数被编译成了一个类的实例，如果函数（就像一个类的实例一样）仅仅是一个指针，你会意识到栈中返回指令的指针和连续参数实际上是一个东西。这也就意味着（在指令语言中）任何一个给定执行点上，你可以获取一个当前状态下的连续（也就是当前栈中的信息）。

现在我们知道当前连续是什么了。这意味着什么呢？当我们得到了当前的连续并且把他们存储到一个地方，我们最后就将当前程序的状态存下来了 - 及时冻结了它。这就像操作系统将自己置于睡眠状态。连续对象包含所有必要的信息来在连续所在的地方重启程序。当你的执行上下文在进程之间切换，操作系统会给你提供支持。唯一的不同就是连续可以控制所有的事情。如果你要获取一个连续对象（在Schema语言中，通过执行`call-with-current-continuation`函数来实现）你会获取到一个包含当前连续的对象。当你选择使用这个连续对象俩重启应用时，程序的状态会直接转换到连续对象所标注的那个时候点上。这和唤起暂停的进程一样，或者唤起一个休眠的操作系统。你就可以不断的在一个点上一直重启，就好像时间回流一样。你可以通过连续来控制程序。

什么情况下连续才是有用的？通常，当你试着去在一个本身就无状态的应用上模拟状态时就会变得很简单。连续的一个明显的应用就是web应用。微软的ASP.NET大量尝试着去模拟状态使你可以更方便的编写应用。如果C#支持连续，ASP.NET一半的复杂度就会消失，你简单的存储一个连续对象，当用户再次访问时重启他。对web应用程序员而言编程也就会更顺畅 —— 程序仅仅会从下一行启动！对一些问题，连续是一个非常强大的抽象方案。想象一下将很多重量级的客户端移到web平台上，在未来连续将会变得越来越重要。

## 模式匹配

模式匹配并不是一个新的或者创新的特性。实际上，它和函数式编程并没有多大的关系。它之所以是函数式编程的一个特性，原因就是函数式语言中有时会用到模式匹配，同时当前的指令性语言中却仍然用的不多。

让我们通过一个例子来了解下模式匹配。下面是Fibonacci函数的Java实现：
{% highlight java%}
int fib(int n) {
  if (n == 0) return 1;
  if (n == 1) return 1;
  return fib(n-2) + fib(n-1);
}
{% endhighlight %}
下面是一个Fibonacci函数的例子，使用Java驱动的语言支持模式匹配：
{% highlight java%}
int fib(0) {
  return 1;
}

int fib(1) {
  return 1;
}

int fib(int n) {
  return fib(n-2) + fib(n-1);
}
{% endhighlight %}
有什么不同吗？编译器帮我们实现了分支选择。

有什么大不了的吗？并没有。有些人注意到了很多函数包含很多复杂的switch语句（在函数式语言中尤其如此）并且认识到最好将此抽象化。当函数被调用，编译器在运行时比较参数的不同，并选择一个正确的那个。这通常是通过选择最明确定义的那个可用的定义。例如，`int fib(int n)`可以通过将`n`赋值`1`，但是编译器却并没有这样，因为`fib(1)`更加的具体。

模式匹配通常比我们例子中的要复杂的多。例如，一个高级的模式匹配系统将会允许我们做如下的事：
{% highlight java%}
int f(int n < 10) {...}
int f(int n){...}
{% endhighlight %}
什么时候模式匹配会比较有用呢？在特别特别多的情况下！每当你有一个复杂的多层`if`语句结构时，模式匹配可以使用更少的代码来更好的完成工作。一个很好的函数实例是标准的`wndProc`函数，这个函数需要所有的Win32应用去实现它（尽管他经常被抽象化了）。通常模式匹配系统可以想校验简单数值一样校验集合。例如，你可以将一个数组传递给你的函数，并且只挑选第一个参数是1以及第三个参数比3大的那个。

另一个模式匹配的好处就是，如果你要增加或者改变条件，你不必进入一个巨型函数中。你只需简单的增加（或者改变）适当的函数定义就好。这就消除了整个GoF(四人帮）的设计模式。你的条件越是复杂，模式匹配对你就会越有用。一旦你习惯了模式匹配，你就会开始怀疑你之前在没有它的时候是怎么度过的。

## 闭包

到目前为止，我们都在讨论纯的函数式语言中的特点 —— 实现lambda演算的语言以及和Church的形式理论无冲突的特性。然而，很多函数式语言的特性在lambda演算框架之外也很有用。因为它允许想数学那样推理程序，对于公理理论系统的实现是有用的，但是却并不总是切合实际。很多这样的语言（例如Common Lisp)从来不将要求变量为final——你可以就地改变任何东西。他们也不需要函数依赖于他们的参数 - 函数允许访问他们的外部状态。但是他们包含函数式语言的特点——例如高阶函数。将函数传递给非严格函数式语言会和lambda演算有点不同，需要一个有趣的特性支持，通常被称为词法闭包。让我们看一段同样的代码。记住，在这个情况下，变量并不是final的，函数可以在他们的作用域外引用变量。
{% highlight java%}
Function makePownerFn(int power) {
  int powerFn(int base) {
    return pow(base, power);
  }

  return powerFn;
}

Function square = makePowerFn(2);
square(3);
{% endhighlight %}
函数`make-power-fn`返回一个函数，这个函数只有一个参数。当我们尝试去执行`square(3)`会发生什么？变量`power`并不在`powerFn`的作用域内，因为`makePowerFn`已经返回，它所在的栈已经消失了。那么`square`如何运行呢？所以语言必须能够将`power`的值存储起来让`square`可以正常运行。如果我们创建另一个函数，比如`cube`将一些数值进行开方呢？运行状态必须能够存储两份`power`值，给每个使用`make-power-fn`生成的函数。将这些值保存起来的现象被称作闭包。闭包不仅仅存储一个宿主函数的参数。例如，闭包可以像下面这样：
{% highlight java%}
Function makeIncrementer() {
  int n = 0;

  int increment() {
    return ++n;
  }
}

Function inc1 = makeIncrementer();
Function inc2 = makeIncrementer();

inc1();
inc1();
int1();
int2();
int2();
int2();
{% endhighlight %}
运行程序尝试去管理存储`n`， 所以自增器可以访问到它。进一步来讲，它存储很多拷贝，每个自增器都有一个，即使他们在`makeIncrementer`返回的时候就应该消失了。这个代码会被编译成什么呢？在背后闭包是如何工作的呢？幸运的是，我们一个后台通道。

这里有一个小共识被远远甩开了。第一个就是本地变量不再局限于简单的作用域规则了并且有了无限的存活时间。明显的结论就是他们不再存储在栈中 —— 他们一定被取而代之的存在了堆中。那么闭包就像我们之前讨论的函数一样，除了他对外部变量有额外的引用。
{% highlight java%}
class some_function_t {
  SymbolTable parentScope;
  // ...
}
{% endhighlight %}
当我们闭包引用非它本作用域的变量时，他会向他的父级作用域去查找。就是这样！闭包将函数式编程和面向对象世界结合的更紧密。每次当你创建一个保存一些状态的类并且将他们传递到一些其他的地方，想想闭包。闭包就是一个从作用域中实时创建成员变量的对象，所以你无需自己设置成员变量。

## 接下来是什么？

这表文章仅仅从表面上剖析了函数式编程。有时候一个小的开始可以发展成更大的东西，就我们而言这是件好事。将来我计划写更多具体各种理论，单体，函数式数据结构，函数式语言中的类型系统，函数式并发，函数式数据库以及更多。如果我已近完成（已经开始学习了）这些话题的一半，那么我的人生就完整了。同时谷歌是我们的朋友。

## 评论？

如果你有任何问题，评论，或者建议，请邮件我coffeemug@gmail.com。我会很高兴看到你的反馈的。
